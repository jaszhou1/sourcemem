#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)")
QPP
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd('C:/Users/jason/Documents/GitHub/sourcemem/analysis/data')
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]
bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])
n.bins <- length(bin.edge.right)
RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
for(i in 1:n.bins) {
this.min <- bin.edge.left[i]
this.max <- bin.edge.right[i]
this.subset <- dataset.recognised[(dataset.recognised$response_error >= this.min)&(dataset.recognised$response_error < this.max), ]
this.RTQuantile<- quantile(this.subset$response_RT,
probs=c(0.1, 0.3, 0.5, 0.7, 0.9))
RTQ <- rbind(RTQ,this.RTQuantile)
#data.subset <- rbind(data.subset,this.subset)
}
All.Q <- data.frame(matrix(ncol=4,nrow=45))
All.Q[,1] <- rep(c(1:9),each = 5)
All.Q[1:20,2] <- rep(bin.edge.left[1:4],each = 5)
All.Q[21:25,2]<- rep(0)
All.Q[26:45,2] <- rep(bin.edge.right[6:9],each = 5)
All.Q[,3] <- c(.1,.3,.5,.7,.9)
#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
QPP
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd('C:/Users/jason/Documents/GitHub/sourcemem/analysis/data')
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]
bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])
n.bins <- length(bin.edge.right)
RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
for(i in 1:n.bins) {
this.min <- bin.edge.left[i]
this.max <- bin.edge.right[i]
this.subset <- dataset.recognised[(dataset.recognised$response_error >= this.min)&(dataset.recognised$response_error < this.max), ]
this.RTQuantile<- quantile(this.subset$response_RT,
probs=c(0.1, 0.3, 0.5, 0.7, 0.9))
RTQ <- rbind(RTQ,this.RTQuantile)
#data.subset <- rbind(data.subset,this.subset)
}
All.Q <- data.frame(matrix(ncol=4,nrow=45))
All.Q[,1] <- rep(c(1:9),each = 5)
All.Q[1:20,2] <- rep(bin.edge.left[1:4],each = 5)
All.Q[21:25,2]<- rep(0)
All.Q[26:45,2] <- rep(bin.edge.right[6:9],each = 5)
All.Q[,3] <- c(.1,.3,.5,.7,.9)
#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
# The palette with grey:
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
QPP
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd('C:/Users/jason/Documents/GitHub/sourcemem/analysis/data')
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]
bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])
n.bins <- length(bin.edge.right)
RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
for(i in 1:n.bins) {
this.min <- bin.edge.left[i]
this.max <- bin.edge.right[i]
this.subset <- dataset.recognised[(dataset.recognised$response_error >= this.min)&(dataset.recognised$response_error < this.max), ]
this.RTQuantile<- quantile(this.subset$response_RT,
probs=c(0.1, 0.3, 0.5, 0.7, 0.9))
RTQ <- rbind(RTQ,this.RTQuantile)
#data.subset <- rbind(data.subset,this.subset)
}
All.Q <- data.frame(matrix(ncol=4,nrow=45))
All.Q[,1] <- rep(c(1:9),each = 5)
All.Q[1:20,2] <- rep(bin.edge.left[1:4],each = 5)
All.Q[21:25,2]<- rep(0)
All.Q[26:45,2] <- rep(bin.edge.right[6:9],each = 5)
All.Q[,3] <- c(.1,.3,.5,.7,.9)
#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
# The palette with grey:
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
QPP
ggsave("RTQ.jpeg", plot = QPP)
setwd("~/GitHub/sourcemem/analysis/data/modelPredictionsNoC")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data/modelPredictionsNoC")
Mix <- read.csv("mixCum.csv", header = FALSE)
VP <- read.csv("vpCum.csv", header = FALSE)
time <- read.csv("time.csv", header = FALSE)
theta <- read.csv("theta.csv", header = FALSE)
angles <- theta[1,]
ys <- time[1,]
nrows <- nrow(Mix)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
xs <- Mix[i,]
this.Quantile<- approx(xs, ys, c(0.1, 0.3, 0.7))
#this.Quantile<- interp[["y"]]
Q <- rbind(Q,this.Quantile)
}
#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
plotQ = data.frame(matrix(ncol=3,nrow=153))
angles <- t(angles)
plotQ[,1]=rep(angles[,1],each=3)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data/modelPredictionsNoC")
Mix <- read.csv("mixCum.csv", header = FALSE)
VP <- read.csv("vpCum.csv", header = FALSE)
time <- read.csv("time.csv", header = FALSE)
theta <- read.csv("theta.csv", header = FALSE)
angles <- theta[1,]
ys <- time[1,]
nrows <- nrow(Mix)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
xs <- Mix[i,]
this.Quantile<- approx(xs, ys, c(0.1, 0.3, 0.7))
#this.Quantile<- interp[["y"]]
Q <- rbind(Q,this.Quantile)
}
#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
plotQ = data.frame(matrix(ncol=3,nrow=150))
angles <- t(angles)
plotQ[,1]=rep(angles[,1],each=3)
plotQ[,2]=Q[,1]
plotQ[,3]=Q[,2]
colnames(plotQ) <- c("Error","RT_Quantile","RT")
plotQ$RT_Quantile <- as.factor(plotQ$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
MixQPP <- ggplot(data = plotQ,aes(x=plotQ$Error, y=plotQ$RT, group=plotQ$RT_Quantile, colour = RT_Quantile)) + geom_line() + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
MixQPP
#Same but with VP
angles <- theta[1,]
ys <- time[1,]
nrows <- nrow(VP)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
xs <- VP[i,]
this.Quantile<- approx(xs, ys, c(0.1, 0.3, 0.7))
#this.Quantile<- interp[["y"]]
Q <- rbind(Q,this.Quantile)
}
#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
plotQ = data.frame(matrix(ncol=3,nrow=150))
angles <- t(angles)
plotQ[,1]=rep(angles[,1],each=3)
plotQ[,2]=Q[,1]
plotQ[,3]=Q[,2]
colnames(plotQ) <- c("Error","RT_Quantile","RT")
plotQ$RT_Quantile <- as.factor(plotQ$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
VPQPP <- ggplot(data = plotQ,aes(x=plotQ$Error, y=plotQ$RT, group=plotQ$RT_Quantile, colour = RT_Quantile)) + geom_line() + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
VPQPP
ggsave("VP.jpeg", plot = VPQPP)
ggsave("Mix.jpeg", plot = MixQPP)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data/modelPredictionsNoC")
Mix <- read.csv("mixCum.csv", header = FALSE)
VP <- read.csv("vpCum.csv", header = FALSE)
time <- read.csv("time.csv", header = FALSE)
theta <- read.csv("theta.csv", header = FALSE)
angles <- theta[1,]
ys <- time[1,]
nrows <- nrow(Mix)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
xs <- Mix[i,]
this.Quantile<- approx(xs, ys, c(0.1, 0.3, 0.7))
#this.Quantile<- interp[["y"]]
Q <- rbind(Q,this.Quantile)
}
#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
plotQ = data.frame(matrix(ncol=3,nrow=150))
angles <- t(angles)
plotQ[,1]=rep(angles[,1],each=3)
plotQ[,2]=Q[,1]
plotQ[,3]=Q[,2]
colnames(plotQ) <- c("Error","RT_Quantile","RT")
plotQ$RT_Quantile <- as.factor(plotQ$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
MixQPP <- ggplot(data = plotQ,aes(x=plotQ$Error, y=plotQ$RT, group=plotQ$RT_Quantile, colour = RT_Quantile)) + geom_line() + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
MixQPP
ggsave("Mix.jpeg", plot = MixQPP)
#Same but with VP
angles <- theta[1,]
ys <- time[1,]
nrows <- nrow(VP)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
xs <- VP[i,]
this.Quantile<- approx(xs, ys, c(0.1, 0.3, 0.7))
#this.Quantile<- interp[["y"]]
Q <- rbind(Q,this.Quantile)
}
#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
plotQ = data.frame(matrix(ncol=3,nrow=150))
angles <- t(angles)
plotQ[,1]=rep(angles[,1],each=3)
plotQ[,2]=Q[,1]
plotQ[,3]=Q[,2]
colnames(plotQ) <- c("Error","RT_Quantile","RT")
plotQ$RT_Quantile <- as.factor(plotQ$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
VPQPP <- ggplot(data = plotQ,aes(x=plotQ$Error, y=plotQ$RT, group=plotQ$RT_Quantile, colour = RT_Quantile)) + geom_line() + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
VPQPP
ggsave("VP.jpeg", plot = VPQPP)
head(dataset.recognised)
setwd("~/GitHub/sourcemem/analysis/data")
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
head(dataset.recognised)
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
head(dataset.recognised)
for (i in 1:participants){[(dataset.recognised$participant == i),]
data <- dataset.recognised
nam <- paste("data", i, sep = "_")
assign(nam, data)
}
for (i in 1:participants){
data <- dataset.recognised[(dataset.recognised$participant == i),]
nam <- paste("data", i, sep = "_")
assign(nam, data)
}
for (i in 1:nrow(participants)){
data <- dataset.recognised[(dataset.recognised$participant == i),]
nam <- paste("data", i, sep = "_")
assign(nam, data)
}
for (i in 1:length(participants)){
data <- dataset.recognised[(dataset.recognised$participant == i),]
nam <- paste("data", i, sep = "_")
assign(nam, data)
}
i = 4
data_"i"
data_i
i = 4
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data")
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
for (i in participants){
#Individual Data
data <- dataset.recognised[(dataset.recognised$participant == i),]
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]
bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])
n.bins <- length(bin.edge.right)
RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
for(i in 1:n.bins) {
this.min <- bin.edge.left[i]
this.max <- bin.edge.right[i]
this.subset <- data[(data$response_error >= this.min)&(data$response_error < this.max), ]
this.RTQuantile<- quantile(this.subset$response_RT,
probs=c(0.1, 0.5, 0.9))
RTQ <- rbind(RTQ,this.RTQuantile)
#data.subset <- rbind(data.subset,this.subset)
}
All.Q <- data.frame(matrix(ncol=4,nrow=27))
All.Q[,1] <- rep(c(1:9),each = 3)
All.Q[1:12,2] <- rep(bin.edge.left[1:4],each = 3)
All.Q[13:15,2]<- rep(0)
All.Q[16:27,2] <- rep(bin.edge.right[6:9],each = 3)
All.Q[,3] <- c(.1,.3,.7)
#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
#QPP
nam <- paste("Plot", i, sep = "")
assign(nam, QPP)
}
View(Plot9)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data")
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
for (i in participants){
#Individual Data
data <- dataset.recognised[(dataset.recognised$participant == i),]
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]
bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])
n.bins <- length(bin.edge.right)
RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
for(i in 1:n.bins) {
this.min <- bin.edge.left[i]
this.max <- bin.edge.right[i]
this.subset <- data[(data$response_error >= this.min)&(data$response_error < this.max), ]
this.RTQuantile<- quantile(this.subset$response_RT,
probs=c(0.1, 0.5, 0.9))
RTQ <- rbind(RTQ,this.RTQuantile)
#data.subset <- rbind(data.subset,this.subset)
}
All.Q <- data.frame(matrix(ncol=4,nrow=27))
All.Q[,1] <- rep(c(1:9),each = 3)
All.Q[1:12,2] <- rep(bin.edge.left[1:4],each = 3)
All.Q[13:15,2]<- rep(0)
All.Q[16:27,2] <- rep(bin.edge.right[6:9],each = 3)
All.Q[,3] <- c(.1,.3,.7)
#Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
RTtrans <- t(RTQ)
All.Q[,4] <- c(RTtrans)
colnames(All.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
All.Q$RT_Quantile <- as.factor(All.Q$RT_Quantile)
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
QPP <- ggplot(data = All.Q,aes(x=All.Q$Error, y=All.Q$RT, group=All.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)
#QPP
filename <- paste("rtQuantile_",i,".png", sep="")
ggsave(filename, plot = QPP)
}
for (i in participants){}
for (i in participants){
i
}
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
setwd("~/GitHub/sourcemem/analysis/data")
dataset <- read.csv("dataset.csv", na.strings = " NA")
dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
# Set up all the different dataset subsets
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20")
#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]
dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)
dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
for (i in participants){
#Individual Data
this.data <- dataset.recognised[(dataset.recognised$participant == i),]
indData <- rbind(indData,this.data)
}
