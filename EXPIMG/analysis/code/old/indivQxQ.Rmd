---
title: "indivQxQ"
author: "jason"
date: "March 14, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/analysis/data/modelPredictionsNoC/Individual")
library(ggplot2)
```

```{r} 
#Model
participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20") 

for (i in participants){
  
  joint<-paste(i,"jointDist",sep="_")
  theta<-paste(i,"theta",sep="_")
  time<-paste(i,"time",sep="_")
  
  assign(joint,read.csv(paste(i,"jointDist.csv",sep=""),header = FALSE))
  assign(theta,read.csv(paste(i,"theta.csv",sep=""), header = FALSE))
  assign(time,read.csv(paste(i,"time.csv",sep=""), header = FALSE))
}


```


```{r}
#data
setwd("~/GitHub/sourcemem/analysis/data")

dataset <- read.csv("dataset.csv", na.strings = " NA")

dataset <- dataset[,-1] #removes the first variable, which are these weird row labels
dataset[,3] <- as.numeric(factor(dataset$condition, levels=c(' LOW', ' HIGH')))
dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete



# Set up all the different dataset subsets

#Group Level
# No Recognition Foils 
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
dataset.na <- dataset[dataset$type==' FOIL', ]


# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == 1, ]
dataset.high <- dataset.no.na[dataset.no.na$condition == 2, ]

participants = c("1","2","3","4","5","6","7","8","9","10","11","12","13","15","16","17","18","19","20") 

#recognition ratings
dataset.recog_1 <- dataset.no.na[dataset.no.na$recog_rating==1, ]
dataset.recog_2 <- dataset.no.na[dataset.no.na$recog_rating==2, ]
dataset.recog_3 <- dataset.no.na[dataset.no.na$recog_rating==3, ]
dataset.recog_4 <- dataset.no.na[dataset.no.na$recog_rating==4, ]
dataset.recog_5 <- dataset.no.na[dataset.no.na$recog_rating==5, ]
dataset.recog_6 <- dataset.no.na[dataset.no.na$recog_rating==6, ]

dataset.unrecognised <- rbind(dataset.recog_1, dataset.recog_2, dataset.recog_3)

dataset.recognised <- rbind(dataset.recog_4, dataset.recog_5, dataset.recog_6)

dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT>10),]
dataset.recognised <- dataset.recognised[!(dataset.recognised$response_RT<.25),]

for (i in participants){
  data <- dataset.recognised[dataset.recognised$participant==i, ]
  name <- paste("part",i,sep = "_")
  assign(name, data)
}

```

```{r}

jointP<- `1_jointDist`
theta <- `1_theta`
time <- `1_time`


angles <- theta[1,]
ys <- time[1,]

nrows <- nrow(jointP)
Q <- data.frame(matrix(ncol=0,nrow=0))
for (i in 1:nrows){
  xs <- jointP[i,]
  this.Quantile<- approx(xs, ys, c(0.1, 0.5, 0.9))
  #this.Quantile<- interp[["y"]]
   Q <- rbind(Q,this.Quantile)
}

#QPP <- ggplot(data = Q,aes(x=, y=, group=, colour = )) + geom_point() + geom_smooth(se=FALSE) + labs(title ="Response Time Quantiles by Error", x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette)

modelQ = data.frame(matrix(ncol=3,nrow=153))
angles <- t(angles)
modelQ[,1]=rep(angles[,1],each=3)
modelQ[,2]=Q[,1]
modelQ[,3]=Q[,2]

colnames(modelQ) <- c("Error","RT_Quantile","RT")

modelQ$RT_Quantile <- as.factor(modelQ$RT_Quantile)

cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")


#Data
k<- 1

data <- dataset.recognised[dataset.recognised$participant==k, ]

# setting up angles for data
bin.edge.right <- seq(-pi, pi, length.out = 10)
bin.edge.right <- bin.edge.right[-1]

bin.edge.left <- c(-pi, bin.edge.right[1:(length(bin.edge.right)-1)])

n.bins <- length(bin.edge.right)

  
  RTQ <- data.frame(matrix(ncol=0,nrow=0))
#Within those quantile bins, work out the RT quantiles
    for(j in 1:n.bins) {
      this.min <- bin.edge.left[j]
      this.max <- bin.edge.right[j]
      this.subset <- data[(data$response_error >= this.min)&(data$response_error < this.max), ]
       this.RTQuantile<- quantile(this.subset$response_RT, 
                                probs=c(0.1, 0.5, 0.9))
       RTQ <- rbind(RTQ,this.RTQuantile)
      #data.subset <- rbind(data.subset,this.subset)
    }
    
    data.Q <- data.frame(matrix(ncol=4,nrow=27))
    data.Q[,1] <- rep(c(1:9),each = 3)
    data.Q[1:12,2] <- rep(bin.edge.left[1:4],each = 3)
    data.Q[13:15,2]<- rep(0)
    data.Q[16:27,2] <- rep(bin.edge.right[6:9],each = 3)
    data.Q[,3] <- c(.1,.5,.9)
    
    #Had a bit of difficulty getting the third column (Actual RTs) in- this is my shoddy workaround
    RTtrans <- t(RTQ)
    data.Q[,4] <- c(RTtrans)
    
    colnames(data.Q) <- c("Error_Bin","Error","RT_Quantile","RT")
    
    data.Q$RT_Quantile <- as.factor(data.Q$RT_Quantile)
    
 
name = paste("rtQuantile",i,sep="_")
       
#rtPlot <- ggplot(data = data.Q,aes(x=data.Q$Error, y=data.Q$RT, group=data.Q$RT_Quantile, colour = RT_Quantile)) + geom_point() + geom_smooth(se=FALSE) + labs(title =paste("QxQ, Participant No. ",j,sep = " "), x = "Response Error (degrees)", y = "Response Time (s)") + scale_colour_manual(values=cbPalette) 


QxQ <- ggplot(data = modelQ,aes(x=modelQ$Error, y=modelQ$RT, group=modelQ$RT_Quantile, colour = RT_Quantile)) + geom_line() + labs(title =paste("QxQ, Participant No. ",k,sep = " "), x = "Response Error (degrees)", y = "Response Time (s)") + geom_point(data = data.Q, aes(x=data.Q$Error, y=data.Q$RT, group=data.Q$RT_Quantile, colour = RT_Quantile)) + geom_smooth(se=FALSE)

QxQ
#ggsave("QxQ_1.jpeg", plot = MixQPP)
```