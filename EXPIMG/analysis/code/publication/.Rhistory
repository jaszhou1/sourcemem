for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
# Get a list of the subject strings you created just to double check
data.subjString <- unique(dataset$subjString)
#Custom function to subset model predictions within the minimum and maximum bin of response
truncate.model <-function(dataset){
res <- data.frame()
participants <- unique(dataset$participant)
for(p in participants) {
min.error <- min(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
max.error <- max(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " false"), ])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " true") &
(dataset$theta < max.error) &
(dataset$theta > min.error), ])
}
res
}
dataset_b <- truncate.model(dataset)
data_low <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' false'),]
model_low <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' false'),]
data_high <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' true'),]
model_high <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' true'),]
#Find means across high and low imageability conditions
data <- setNames(data.frame(matrix(ncol = 6, nrow = nrow(data_low))),
c("subject", "theta_high","theta_low",
"rt_high","rt_low","quantile_idx"))
#Data
data$subject <- data_high$subjString
data$theta_high <- data_high$theta
data$theta_low <- data_low$theta
data$rt_high <- data_high$rt
data$rt_low <- data_low$rt
data$quantile_idx <- data_high$quantile_idx
data$theta_mean <- rowMeans(data[c('theta_high', 'theta_low')], na.rm=TRUE)
data$rt_mean <- rowMeans(data[c('rt_high', 'rt_low')], na.rm=TRUE)
#Convert to Absolute
#Split dataframe by subject
splitData<- split(data, data$subject)
# Custom function to convert QxQ data into absolute (average absolute theta, average rt)
to.absolute <- function(n, dataset){
}
lapply(splitData, to.absolute)
#Hybrid Model
model <- model_high
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# The palette with black:
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# Setup equally spaced colours around wheel
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 3
cols = gg_color_hue(n)
# ------------ Plot Data ---------------------------------
QxQ <- ggplot() +
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as LINES
# Continuous
# Threshold
# Hybrid
# Theme
# ------------ Group plot by participant -----------------
facet_wrap(~subject, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as POINTS
QxQ <- ggplot(data = model,
aes(x = model$theta,
y = model$rt,
group = model$quantile_idx,  # group points according to quantiles
colour = quantile_idx)) +
geom_line(linemitre = 4) +
# ------------ Plot Data ---------------------------------
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ------------ Group plot by participant -----------------
facet_wrap(~subjString, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
QxQ # display the plot
View(model)
View(data)
rm(list = ls())
# knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plyr)
library(tidyverse)
library(readr)
library(abind)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
dataset <- read.csv("2020-01-02_NoCritQQ_Hybrid.csv")
dataset$quantile_idx <- as.factor(dataset$quantile_idx)
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
# Get a list of subjects
data.subjList <- unique(dataset$participant)
# Custom function to create new variable labels
create.subj.string <- function(n, dataset){
dataset[dataset$participant==n, 'subjString'] <- sprintf("Subject %d", n)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
# Get a list of the subject strings you created just to double check
data.subjString <- unique(dataset$subjString)
#Custom function to subset model predictions within the minimum and maximum bin of response
truncate.model <-function(dataset){
res <- data.frame()
participants <- unique(dataset$participant)
for(p in participants) {
min.error <- min(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
max.error <- max(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " false"), ])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " true") &
(dataset$theta < max.error) &
(dataset$theta > min.error), ])
}
res
}
dataset_b <- truncate.model(dataset)
data_low <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' false'),]
model_low <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' false'),]
data_high <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' true'),]
model_high <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' true'),]
#Find means across high and low imageability conditions
data <- setNames(data.frame(matrix(ncol = 6, nrow = nrow(data_low))),
c("subject", "theta_high","theta_low",
"rt_high","rt_low","quantile_idx"))
#Data
data$subject <- data_high$subjString
data$theta_high <- data_high$theta
data$theta_low <- data_low$theta
data$rt_high <- data_high$rt
data$rt_low <- data_low$rt
data$quantile_idx <- data_high$quantile_idx
data$theta_mean <- rowMeans(data[c('theta_high', 'theta_low')], na.rm=TRUE)
data$rt_mean <- rowMeans(data[c('rt_high', 'rt_low')], na.rm=TRUE)
#Convert to Absolute
#Split dataframe by subject
splitData<- split(data, data$subject)
# Custom function to convert QxQ data into absolute (average absolute theta, average rt)
to.absolute <- function(n, dataset){
}
lapply(splitData, to.absolute)
#Hybrid Model
model <- model_high
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# The palette with black:
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# Setup equally spaced colours around wheel
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 3
cols = gg_color_hue(n)
# ------------ Plot Data ---------------------------------
QxQ <- ggplot() +
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as LINES
# Continuous
# Threshold
# Hybrid
# Theme
# ------------ Group plot by participant -----------------
facet_wrap(~subject, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
View(data)
View(model)
View(dataset)
head(model)
head(data)
View(model_high)
View(model_low)
View(model)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
library(tidyverse)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
library(tidyverse)
dataset <- read.csv('dataFiltered3.csv')
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
#dataset <- dataset[!(dataset$participant== 1),]
#dataset <- dataset[!(dataset$participant== 13),]
# Get a list of subjects
data.subjList <- unique(dataset$participant)
#data.subjList <- c(1,2,3,4)
# Custom function to create new variable labels
create.subj.string <- function(subjNo, dataset){
dataset[dataset$participant==subjNo, 'subjString'] <- sprintf('Subject %d', subjNo)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
dataset$participant <- factor(dataset$participant, levels = unique(dataset$participant))
recogdata <- dataset[dataset$recog_rating>3,]
lowdata <- recogdata[recogdata$condition==1,]
highdata <- recogdata[recogdata$condition==2,]
View(highdata)
View(lowdata)
rm(list = ls())
# knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plyr)
library(tidyverse)
library(readr)
library(abind)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
dataset <- read.csv("2020-01-02_NoCritQQ_Hybrid.csv")
dataset$quantile_idx <- as.factor(dataset$quantile_idx)
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
# Get a list of subjects
data.subjList <- unique(dataset$participant)
# Custom function to create new variable labels
create.subj.string <- function(n, dataset){
dataset[dataset$participant==n, 'subjString'] <- sprintf("Subject %d", n)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
# Get a list of the subject strings you created just to double check
data.subjString <- unique(dataset$subjString)
#Custom function to subset model predictions within the minimum and maximum bin of response
truncate.model <-function(dataset){
res <- data.frame()
participants <- unique(dataset$participant)
for(p in participants) {
min.error <- min(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
max.error <- max(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " false"), ])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " true") &
(dataset$theta < max.error) &
(dataset$theta > min.error), ])
}
res
}
dataset_b <- truncate.model(dataset)
data_low <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' false'),]
model_low <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' false'),]
data_high <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' true'),]
model_high <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' true'),]
#Find means across high and low imageability conditions
data <- setNames(data.frame(matrix(ncol = 6, nrow = nrow(data_low))),
c("subject", "theta_high","theta_low",
"rt_high","rt_low","quantile_idx"))
#Data
data$subject <- data_high$subjString
data$theta_high <- data_high$theta
data$theta_low <- data_low$theta
data$rt_high <- data_high$rt
data$rt_low <- data_low$rt
data$quantile_idx <- data_high$quantile_idx
data$theta_mean <- rowMeans(data[c('theta_high', 'theta_low')], na.rm=TRUE)
data$rt_mean <- rowMeans(data[c('rt_high', 'rt_low')], na.rm=TRUE)
#Convert to Absolute
#Split dataframe by subject
splitData<- split(data, data$subject)
# Custom function to convert QxQ data into absolute (average absolute theta, average rt)
#to.absolute <- function(n, dataset){
#}
#lapply(splitData, to.absolute)
#Hybrid Model
#model <- model_high
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# The palette with black:
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# Setup equally spaced colours around wheel
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 3
cols = gg_color_hue(n)
# ------------ Plot Data ---------------------------------
QxQ <- ggplot() +
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as LINES
# Continuous
# Threshold
# Hybrid
# Theme
# ------------ Group plot by participant -----------------
facet_wrap(~subject, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
QxQ
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
library(circular)
setwd("~/GitHub/sourcemem/EXPIMG/analysis/data")
dataset <- read.csv('dataFiltered3.csv')
dataset.recog <- dataset[dataset$recog_rating>3, ]
dataset.unrecog <- dataset[dataset$recog_rating<=3, ]
all <- modified.rayleigh(dataset)
View(all)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(all)
View(unrecognised)
hist(dataset.unrecog[dataset.unrecog$participant==1,]$response_error)
hist(dataset.unrecog[dataset.unrecog$participant==11,]$response_error)
hist(dataset.unrecog[dataset.unrecog$participant==18,]$response_error)
hist(dataset.unrecog[dataset.unrecog$participant==13,]$response_error)
hist(dataset.unrecog[dataset.unrecog$participant==11,]$response_error)
nrow(dataset.unrecog[dataset.unrecog$participant==11,])
nrow(dataset.unrecog[dataset.unrecog$participant==13,])
nrow(dataset[dataset$participant==11,])
nrow(dataset[dataset$participant==12,])
nrow(dataset[dataset$participant==13,])
(44/546)*100
dataset.unrecog <- dataset[dataset$recog_rating<3, ]
unrecognised <- modified.rayleigh(dataset.unrecog)
View(unrecognised)
nrow(dataset.unrecog[dataset.unrecog$participant==11,])
hist(dataset.unrecog[dataset.unrecog$participant==11,]$response_error)
(44/546)*100
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
setwd("~/GitHub/sourcemem/EXPIMG/analysis/code/publication")
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/code/publication/publicationfigure_qxq.R', echo=TRUE)
