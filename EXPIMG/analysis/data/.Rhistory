# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ------------ Group plot by participant -----------------
facet_wrap(~subjString, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
QxQ # display the plot
View(model)
View(data)
rm(list = ls())
# knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plyr)
library(tidyverse)
library(readr)
library(abind)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
dataset <- read.csv("2020-01-02_NoCritQQ_Hybrid.csv")
dataset$quantile_idx <- as.factor(dataset$quantile_idx)
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
# Get a list of subjects
data.subjList <- unique(dataset$participant)
# Custom function to create new variable labels
create.subj.string <- function(n, dataset){
dataset[dataset$participant==n, 'subjString'] <- sprintf("Subject %d", n)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
# Get a list of the subject strings you created just to double check
data.subjString <- unique(dataset$subjString)
#Custom function to subset model predictions within the minimum and maximum bin of response
truncate.model <-function(dataset){
res <- data.frame()
participants <- unique(dataset$participant)
for(p in participants) {
min.error <- min(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
max.error <- max(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " false"), ])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " true") &
(dataset$theta < max.error) &
(dataset$theta > min.error), ])
}
res
}
dataset_b <- truncate.model(dataset)
data_low <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' false'),]
model_low <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' false'),]
data_high <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' true'),]
model_high <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' true'),]
#Find means across high and low imageability conditions
data <- setNames(data.frame(matrix(ncol = 6, nrow = nrow(data_low))),
c("subject", "theta_high","theta_low",
"rt_high","rt_low","quantile_idx"))
#Data
data$subject <- data_high$subjString
data$theta_high <- data_high$theta
data$theta_low <- data_low$theta
data$rt_high <- data_high$rt
data$rt_low <- data_low$rt
data$quantile_idx <- data_high$quantile_idx
data$theta_mean <- rowMeans(data[c('theta_high', 'theta_low')], na.rm=TRUE)
data$rt_mean <- rowMeans(data[c('rt_high', 'rt_low')], na.rm=TRUE)
#Convert to Absolute
#Split dataframe by subject
splitData<- split(data, data$subject)
# Custom function to convert QxQ data into absolute (average absolute theta, average rt)
to.absolute <- function(n, dataset){
}
lapply(splitData, to.absolute)
#Hybrid Model
model <- model_high
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# The palette with black:
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# Setup equally spaced colours around wheel
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 3
cols = gg_color_hue(n)
# ------------ Plot Data ---------------------------------
QxQ <- ggplot() +
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as LINES
# Continuous
# Threshold
# Hybrid
# Theme
# ------------ Group plot by participant -----------------
facet_wrap(~subject, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
View(data)
View(model)
View(dataset)
head(model)
head(data)
View(model_high)
View(model_low)
View(model)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
library(tidyverse)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
library(tidyverse)
dataset <- read.csv('dataFiltered3.csv')
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
#dataset <- dataset[!(dataset$participant== 1),]
#dataset <- dataset[!(dataset$participant== 13),]
# Get a list of subjects
data.subjList <- unique(dataset$participant)
#data.subjList <- c(1,2,3,4)
# Custom function to create new variable labels
create.subj.string <- function(subjNo, dataset){
dataset[dataset$participant==subjNo, 'subjString'] <- sprintf('Subject %d', subjNo)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
dataset$participant <- factor(dataset$participant, levels = unique(dataset$participant))
recogdata <- dataset[dataset$recog_rating>3,]
lowdata <- recogdata[recogdata$condition==1,]
highdata <- recogdata[recogdata$condition==2,]
View(highdata)
View(lowdata)
rm(list = ls())
# knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plyr)
library(tidyverse)
library(readr)
library(abind)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/models/figures/cDiffusionFits")
dataset <- read.csv("2020-01-02_NoCritQQ_Hybrid.csv")
dataset$quantile_idx <- as.factor(dataset$quantile_idx)
# Create a new variable to label the subject numbers as strings
dataset$subjString <- NA
# Get a list of subjects
data.subjList <- unique(dataset$participant)
# Custom function to create new variable labels
create.subj.string <- function(n, dataset){
dataset[dataset$participant==n, 'subjString'] <- sprintf("Subject %d", n)
return(dataset)
}
# Run through loop - don't use lapply or map because subject numbers not in order
for (sub in 1:length(data.subjList)){
# Get the subject number
subjNo <- data.subjList[sub]
# Run function, return data frame (dataset)
dataset <- create.subj.string(subjNo, dataset)
}
# Create as factor for plotting and also include levels so the order is correct
dataset$subjString <- factor(dataset$subjString,
levels = unique(dataset$subjString))
# Get a list of the subject strings you created just to double check
data.subjString <- unique(dataset$subjString)
#Custom function to subset model predictions within the minimum and maximum bin of response
truncate.model <-function(dataset){
res <- data.frame()
participants <- unique(dataset$participant)
for(p in participants) {
min.error <- min(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
max.error <- max(dataset[(dataset$participant == p) &
(dataset$is_model == " false"), 'theta'])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " false"), ])
res <- rbind(res,
dataset[(dataset$participant == p) &
(dataset$is_model == " true") &
(dataset$theta < max.error) &
(dataset$theta > min.error), ])
}
res
}
dataset_b <- truncate.model(dataset)
data_low <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' false'),]
model_low <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' false'),]
data_high <- dataset_b[(dataset_b$is_model==' false') & (dataset_b$is_high==' true'),]
model_high <- dataset_b[(dataset_b$is_model==' true') & (dataset_b$is_high==' true'),]
#Find means across high and low imageability conditions
data <- setNames(data.frame(matrix(ncol = 6, nrow = nrow(data_low))),
c("subject", "theta_high","theta_low",
"rt_high","rt_low","quantile_idx"))
#Data
data$subject <- data_high$subjString
data$theta_high <- data_high$theta
data$theta_low <- data_low$theta
data$rt_high <- data_high$rt
data$rt_low <- data_low$rt
data$quantile_idx <- data_high$quantile_idx
data$theta_mean <- rowMeans(data[c('theta_high', 'theta_low')], na.rm=TRUE)
data$rt_mean <- rowMeans(data[c('rt_high', 'rt_low')], na.rm=TRUE)
#Convert to Absolute
#Split dataframe by subject
splitData<- split(data, data$subject)
# Custom function to convert QxQ data into absolute (average absolute theta, average rt)
#to.absolute <- function(n, dataset){
#}
#lapply(splitData, to.absolute)
#Hybrid Model
#model <- model_high
# The palette with grey:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# The palette with black:
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# Setup equally spaced colours around wheel
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 3
cols = gg_color_hue(n)
# ------------ Plot Data ---------------------------------
QxQ <- ggplot() +
# Plot data as POINTS ONLY
geom_point(data = data,
aes(x = data$theta_mean,
y = data$rt_mean,
group = data$quantile_idx,
colour = quantile_idx)) +
# ---------- Plot Model Predictions ----------------------
# Plot the model predictions as LINES
# Continuous
# Threshold
# Hybrid
# Theme
# ------------ Group plot by participant -----------------
facet_wrap(~subject, labeller = label_wrap_gen(width = 30), ncol = 4, scale = "free") +
# ------------ Change some axes settings  ----------------
#scale_y_continuous(limits=c(0, 3)) +
scale_x_continuous(name ="Response Error (degrees)", # also x axis name
breaks = c(-2, 0, 2),
labels = c(expression(-pi), "0", expression(pi))) +
xlab("Response Error (degrees)") + # just in case remove scale x continuous
ylab("Response Time (s)") +
scale_color_manual(name = "Predicted \nQuantiles",
values = cols,  # cbPalette[c(1,2,3)],
labels = c("0.1", "0.5", "0.9")) +
# ------------ Change Theme Settings  ----------------
ggtitle("Response Time Quantiles by Error \n High Imageability Condition") +
theme(
# Legend settings
#legend.justification = c(1, 1), legend.position = c(0.90, 1.09),
legend.background = element_blank(),
# Axis settingd
axis.text.x = element_text(size=7),  # size of text on the x axis
axis.text.y = element_text(size=7),  # size of text on the y axis
# Plot title settings
plot.title = element_text(hjust = 0.5, size = 13),  # title settings (note, centering requires h = 0.5)
plot.subtitle = element_text(hjust = 0.5), # subtitle settiings (note, centering requires h = 0.5)
plot.caption = element_text(hjust = 0, face = "italic"), # caption settings
# Get rid of background panel grid
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
QxQ
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/analysis/data")
library(circular)
dataset <- read.csv("imageability.csv", na.strings = " NA")
setwd("~/GitHub/sourcemem/EXPIMG/analysis/data")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/analysis/data")
library(circular)
dataset <- read.csv("imageability.csv", na.strings = " NA")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/analysis/data")
library(circular)
dataset <- read.csv("imageability.csv", na.strings = " NA")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/EXPIMG/analysis/data")
library(circular)
dataset <- read.csv("imageability.csv", na.strings = " NA")
#dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
#Filter out
dataset.no.na <- dataset.no.na[!(dataset.no.na$response_RT>10),]
dataset.no.na <- dataset.no.na[!(dataset.no.na$response_RT<.25),]
# Confidence
dataset.unrecog <- dataset.no.na[dataset.no.na$recog_rating<3, ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == ' LOW', ]
dataset.high <- dataset.no.na[dataset.no.na$condition == ' HIGH', ]
#Individual Level
#participants = c("p1","p3","p5")
#for (i in participants){
#sprintf("%s_%s.csv",i)
#  }
participants<-c('p1','p2','p3','p4','p5','p6','p7','p8','p9','p10','p11','p12','p13','p15','p16','p17','p18','p19','p20')
rayleigh<-data.frame(participant=character(0),
statistic=numeric(0),
p.value=numeric(0))
for(p in participants){
this.rayleigh<-rayleigh.test(dataset.unrecog[dataset.unrecog$participant==p,]$response_error)
rayleigh <- rbind(rayleigh,
data.frame(participant = p,
statistic = this.rayleigh$statistic,
p.value = this.rayleigh$p.value))
}
View(rayleigh)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/GitHub/sourcemem/EXPIMG/analysis/data")
library(circular)
dataset <- read.csv("datafiltered3.csv", na.strings = " NA")
#dataset$recog_rating <- as.factor(dataset$recog_rating) #Confidence Ratings are Discrete
#Group Level
# No Recognition Foils
dataset.no.na <- dataset[dataset$type!=' FOIL', ]
#Filter out
dataset.no.na <- dataset.no.na[!(dataset.no.na$response_RT>10),]
dataset.no.na <- dataset.no.na[!(dataset.no.na$response_RT<.25),]
# Confidence
dataset.unrecog <- dataset.no.na[dataset.no.na$recog_rating<3, ]
# Stimulus only, conditioned on imageability+concreteness ratings
dataset.low <- dataset.no.na[dataset.no.na$condition == ' LOW', ]
dataset.high <- dataset.no.na[dataset.no.na$condition == ' HIGH', ]
#Individual Level
#participants = c("p1","p3","p5")
#for (i in participants){
#sprintf("%s_%s.csv",i)
#  }
participants<-c('p1','p2','p3','p4','p5','p6','p7','p8','p9','p10','p11','p12','p13','p15','p16','p17','p18','p19','p20')
rayleigh<-data.frame(participant=character(0),
statistic=numeric(0),
p.value=numeric(0))
for(p in participants){
this.rayleigh<-rayleigh.test(dataset.unrecog[dataset.unrecog$participant==p,]$response_error)
rayleigh <- rbind(rayleigh,
data.frame(participant = p,
statistic = this.rayleigh$statistic,
p.value = this.rayleigh$p.value))
}
setwd("~/GitHub/sourcemem/EXPIMG/analysis/data")
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
head(dataset)
dataset.recog <- dataset[dataset$recog_rating>3, ]
dataset.unrecog <- dataset[dataset$recog_rating<=3, ]
View(dataset.unrecog)
View(dataset.recog)
head(dataset.recog)
participants <- unique(dataset$participant)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
warnings()
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
data<-data.frame(participant=character(0),
statistic=numeric(0),
p.value=numeric(0))
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
recognised
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
warnings()
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
modified.rayleigh(dataset.recog)
modified.rayleigh(dataset.recog)
modified.rayleigh(dataset.recog)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(recognised)
a <- dataset[dataset$participant==1,]$response_error
a <- dataset[dataset$participant==2,]$response_error
a <- dataset[dataset$participant==3,]$response_error
length(a)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(recognised)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(recognised)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(all)
View(unrecognised)
p1 <- dataset[dataset$participant == 1,]
p1_r <- rayleigh.test(p1$response_error)
p1_r
p2 <- dataset[dataset$participant == 2,]
p2_r <- rayleigh.test(p2$response_error)
p2_ntrials <- length(p2)
View(p2_r)
pw_rbar <- p2_r$statistic
2 * p2_ntrials * p2_r$statistic
2 * p2_ntrials * p2_r$statistic^2
2 * 100 * p2_r$statistic^2
pw_ntrials
p2_ntrials
dim(p2)
dim(p2)(1)
nrows(p2)
nrow(p2)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(recognised)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
View(recognised)
View(all)
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
all <- modified.rayleigh(dataset)
res<-data.frame(participant=character(0),
statistic=numeric(0),
p.value=numeric(0))
source('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
all <- modified.rayleigh(dataset)
all <- modified.rayleigh(dataset)
data.frame(participant = p,
statistic = stat,
p.value = this.rayleigh$p.value)
all <- modified.rayleigh(dataset)
p
p
p
stat
all <- modified.rayleigh(dataset)
debugSource('~/GitHub/sourcemem/EXPIMG/analysis/data/rayleigh_test.R', echo=TRUE)
all <- modified.rayleigh(dataset)
all <- modified.rayleigh(dataset)
