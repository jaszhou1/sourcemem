### N.B. I have two versions of the circular diffusion model, one is in C, called from Matlab, the other is pure Matlab. The C-version requires a C compiler and the Gnu maths library. It is blindingly fast but requires some fiddling to get working. The pure Matlab is a bit slower, but not slow enough to be annoying, so that's what I've given you.

I. Data Treatment
-----------------
Raw data in jason-full-dataset.csv

1. Can't read this cleanly into Matlab because it doesn't handle csv files that contain mixed strings and numbers. I read this into Excel, saved as a .xlsx file and then used:

> [J1, J2, J3] =xlsread('jason-full-dataset.xlsx')

which reads the numbers and strings separately. I then manually recoded 'LONG' = 1, 'SHORT' = 0

in J1. This (and individual data) are in Jindiv.mat

J1 contains this recoding 8840 rows = (320 + 360) * 13 (320 trials long, 360 trials short).

2. Make data structures for individual subjects: makesubject (for subject 1):

> [D1a,D1b]=makesubject(1, J1)

This creates two data structures for individual subjects, D1a for long, D1b for short. (Did this for everyone, all saved in Jindiv.)

3. Created new compound structures more convenient for fitting by maximum likelihood

> L1 = makelike(D1a, D1b)

This creates a Matlab cellular array with two components each component is a 2d array: 320 x 2 for long; 360 x 2 for short. The individual components are accessed with the special syntax:

L1{1} accesses long, L1{2} accesses short, etc. L1{1}(:,1) is the (sorted) absolute error; L1{1}(:2) is the associated RT.

4. Descriptive statistics; correlation between accuracy and RT, and Rayleigh test for uniformity (all subjects). Operates on Dlong, Dshort, which are group data for long and short separated.

> [Corri, Vi, Ri] = rterrcorr(Dlong)

Corri is the correlation for each subject (row), Vi is the circular variance (Vi -> 1.0 means uniform on circle); Ri is the Rayleigh test for uniformity: chisquare(2), p > 0.05 means you can't reject the hypothesis of uniformity (randomness).


IIa. Models: Variable precision
-------------------------------
1. Implemented as circular diffusion model with drift variability.

> [ll,bic,Pred] = fitdcircle(P(Sel==1), P(Sel==0), Sel, L1)

Sel is a boolean vector that controls the fixed and variable parameters as in the lab. L1 is the data for subject 1. (This is is created by makelike, but L1 is already there and can be loaded with load L1). ll is (minus) the log-likelihood, which you want to minimize, bic = -2LL + penalty, and Pred is Predicted values for plotting.

> help fitdcircle
  ========================================================================
  Circular diffusion with drift variability for Jason's source memory task.
     [ll,bic,Pred] = fitdcircle(Pvar, Pfix, Sel, Data)
     P = [v1a, v2a, v1b, v2b, eta1a, eta2a, eta1b, eta2b, a, Ter]
           1    2    3    4     5      6      7      8    9   10
     'Data' is cell array structure created by <makelike>
  ========================================================================

Shows the function call. This version allows the drift and drift varaibility components to vary independently.

2. Fitting, set the options:

> setopt

3. Fit with simplex:

> pest = fminsearch(@fitdcircle, P(Sel==1), options, P(Sel==0), Sel, L1)

4. Update parameter vector, generate new predictions, and plot

> P(Sel== 1) = pest 
> [ll,bic,Pred] = fitdcircle(P(Sel==1), P(Sel==0), Sel, L1)
> fitplot(L1, Pred)

With all parameters free: Sel = ones(1,10)

P = [1.0770   -0.0021    1.5682    0.0215    1.5705    0.4799    1.7069    0.0034    1.2469    0.1501]

ll = 1.2898e+03,  bic = 2.6447e+03

This has the second (vertical) component of drift variability smaller than the horizontal (zero error) component, which produces the 'uptick'. 

Constraining the horizontal and vertical eta components to be the same Sel(6) = 0, Sel(8) = 0, sets a switch inside the function, and gives ll = 1.3278e+03. Don't get the uptick, but the fit is very poor.

5. There is a second function, fitdcircle3, which forces the horizontal and vertical etas to be the same (which is what I've done with the mixture model), which does the same thing:
 
 > help fitdcircle3

 ========================================================================
  Circular diffusion with drift variability for Jason's source memory task.
  Assumes the eta components in the x and y directions are the
  same.
     [ll,bic,Pred] = fitdcircle3(Pvar, Pfix, Sel, Data)
     P = [v1a, v2a, v1b, v2b, eta1, eta2, a, Ter]
           1    2    3    4    5      6   7   8
     'Data' is cell array structure created by <makelike>
  ========================================================================

Calling this with Sel = ones(1,8) (i.e., all parameters free) will give the same thing as calling fitdcircle with Sel = [ 1     1     1     1     1     0     1     0     1     1]

IIb: Models: Mixture
--------------------

help fitmixture3
  ========================================================================
  Circular diffusion with drift variability for Jason's source memory task.
  Mixture of memory based and guessing based process with different 
  criteria. Assumes the eta components in the x and y directions are the
  same.
     [ll,bic,Pred] = fitmixture3(Pvar, Pfix, Sel, Data)
     P = [v1a, v2a, v1b, v2b, eta1, eta2, a1, a2, pi1, pi2, Ter]
           1    2    3    4    5      6    7   8   9   10    11
     a1, a2 are criteria for memory and guessing process, pi1, pi2 are 
     mixing proportions for long and short.
     'Data' is cell array structure created by <makelike>
  ========================================================================

I've implemented the guessing process as a zero-drift diffusion, with a different criterion. The idea is that this is an implementation of the idea that if I don't recognize the item, I set the criterion low, and run the same retrieval process. The model allows drift variability, so is really variable precision + "guessing", but if you force the eta parameters to zero with P(5:6) = 0, Sel(5:6) = 0, this will implement a "pure" memory process with guessing.  Here there are only two etas (like fitdcircle3); I've forced the horizontal and vertical etas to be the same, but you can free these up if you want. (I've got a function that does this). 


It's run in the same way:

P = [3.6538   -0.0172    4.0551   -0.0024    1.2835    0.1385    1.9516    1.0743    0.4230    0.4784    0.1335]

% My best parameters for the this subject, but otherwise your best guess at starting parameters.

Sel = ones(1,11)  % all parameters free

> [ll,bic,Pred] = fitmixture3(P(Sel==1), P(Sel==0), Sel, L1)

ll = 1.2516e+03 bic = 2.5750e+03

> pest = fminsearch(@fitmixture3, P(Sel==1), options, P(Sel==0), Sel, L1)
> P(Sel==1) = pest
> [ll,bic,Pred] = fitmixture3(P(Sel==1), P(Sel==0), Sel, L1)
> fitplot(L1, Pred)

The vertical components of drift are very near zero as you would expect them to be, so you can force them to zero and refit:  P(2) = 0, P(4) = 0, Sel(2) = 0, Sel(4) = 0

ll =  1.2516e+03 bic = 2.5619e+03

The LL hasn't altered, but the BIC is better because there are two fewer parameters, so by BIC logic, this is the model you'd prefer. 

This fit looks much better than the variable precision model, although it's still not quite getting the peak, but it is getting better separation between the shoulder and the tail. I haven't looked at other subjects so I don't know if it is systematic.






